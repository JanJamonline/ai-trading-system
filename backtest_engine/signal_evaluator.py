import pandas as pd


class SignalEvaluator:
    """
    Evaluates signal correctness using a fixed look-ahead window.
    NO trading, NO PnL, NO execution.
    Pure signal validation.
    """

    def __init__(self, lookahead_candles: int = 3, flat_tolerance: float = 0.001):
        self.lookahead = lookahead_candles
        self.flat_tolerance = flat_tolerance

    def evaluate(self, signals: list, price_df: pd.DataFrame) -> list:
        """
        signals: list of signal dicts generated by engine
        price_df: original OHLC dataframe

        Returns: list of signals with evaluation results added
        """

        evaluated = []

        # Ensure index alignment
        price_df = price_df.reset_index(drop=True)

        for idx, signal in enumerate(signals):
            eval_result = signal.copy()
            eval_result["evaluation"] = "NOT_EVALUATED"

            future_index = idx + self.lookahead

            if future_index >= len(price_df):
                eval_result["evaluation"] = "INSUFFICIENT_DATA"
                evaluated.append(eval_result)
                continue

            entry_price = signal["price"]
            future_price = price_df.loc[future_index, "close"]

            signal_type = signal["signal"]

            if signal_type == "BUY":
                eval_result["evaluation"] = (
                    "CORRECT" if future_price > entry_price else "WRONG"
                )

            elif signal_type == "SELL":
                eval_result["evaluation"] = (
                    "CORRECT" if future_price < entry_price else "WRONG"
                )

            elif signal_type == "HOLD":
                if abs(future_price - entry_price) <= self.flat_tolerance:
                    eval_result["evaluation"] = "CORRECT"
                else:
                    eval_result["evaluation"] = "WRONG"

            evaluated.append(eval_result)

        return evaluated
